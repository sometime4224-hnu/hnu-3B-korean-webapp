<!DOCTYPE html>
<html lang="ko">
<head>
    <!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-NB76SV96');</script>
<!-- End Google Tag Manager -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>격파왕</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Jua&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Jua', sans-serif;
            touch-action: manipulation;
            overflow: hidden;
        }
        .jua-font {
            font-family: 'Jua', sans-serif;
        }
        .btn-press {
            transition: transform 0.1s ease-in-out, box-shadow 0.1s ease-in-out;
        }
        .btn-press:active {
            transform: scale(0.95);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        /* 피드백 메시지 업데이트 효과 */
        .feedback-update {
            animation: text-pulse 0.4s ease-in-out;
        }
        @keyframes text-pulse {
             0%, 100% { transform: scale(1); filter: brightness(1); }
             50% { transform: scale(1.05); filter: brightness(1.2); }
        }
        
        #target-object {
            cursor: pointer;
            transition: transform 0.2s ease, filter 0.3s ease;
        }
        #target-object.breakable {
            animation: pulse-strong 1.2s infinite;
            filter: drop-shadow(0 0 20px #f59e0b);
        }
        @keyframes pulse-strong {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        #target-object.breaking {
            animation: breaking-zoom 0.2s forwards;
        }
        @keyframes breaking-zoom {
            0% { transform: scale(1.05); }
            100% { transform: scale(0.8); opacity: 0; }
        }

        .particle {
            position: absolute;
            font-size: 20px;
            pointer-events: none;
            animation: fly-out 0.8s ease-out forwards;
        }
        @keyframes fly-out {
            0% { transform: translate(0, 0) scale(1); opacity: 1; }
            100% { transform: translate(var(--x), var(--y)) scale(0); opacity: 0; }
        }

        #success-message.show {
            display: flex;
            animation: success-pop 1s forwards;
        }
        @keyframes success-pop {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }

        #tutorial-arrow {
            position: absolute;
            width: 60px;
            height: 60px;
            pointer-events: none;
            transition: top 0.4s ease, left 0.4s ease, transform 0.4s ease;
            animation: bounce 1s infinite;
            z-index: 10;
        }
        @keyframes bounce {
            0%, 100% { transform: translateY(-10%); }
            50% { transform: translateY(10%); }
        }

        /* 치명타 메시지 */
        .crit-message {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 1.5rem;
            font-weight: bold;
            pointer-events: none;
            animation: crit-pop 1s ease-out forwards;
            z-index: 20;
        }
        @keyframes crit-pop {
            0% { transform: translate(-50%, 0) scale(0.8); opacity: 1; }
            100% { transform: translate(-50%, -80px) scale(1.5); opacity: 0; }
        }

        /* 화면 흔들림 효과 */
        .crit-shake {
            animation: screenShake 0.4s cubic-bezier(.36,.07,.19,.97) both;
        }
        @keyframes screenShake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }
    </style>
</head>
<body class="bg-gray-800 flex items-center justify-center min-h-screen p-4">

    <div id="game-container" class="w-full max-w-sm mx-auto bg-white rounded-3xl shadow-2xl p-6 jua-font text-gray-800 relative">
        
        <div id="tutorial-arrow" class="hidden">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="text-red-500 w-16 h-16 drop-shadow-lg">
                <path fill-rule="evenodd" d="M12.53 16.28a.75.75 0 01-1.06 0l-7.5-7.5a.75.75 0 011.06-1.06L12 14.69l6.97-6.97a.75.75 0 111.06 1.06l-7.5 7.5z" clip-rule="evenodd" />
            </svg>
        </div>

        <div class="absolute top-4 right-6 text-2xl font-bold text-gray-400 flex flex-col items-end">
            <div id="level-indicator">LV. 1</div>
            <div id="timer" class="text-lg">0.0초</div>
        </div>

        <h1 class="text-3xl text-center font-bold text-red-600 mb-4">격파왕</h1>
        
        <div id="target-container" class="w-full aspect-square bg-yellow-100 rounded-2xl shadow-inner mb-4 p-2 flex items-center justify-center overflow-hidden relative">
            <div id="target-object" class="text-8xl md:text-9xl"></div>
            <div id="success-message" class="hidden absolute inset-0 flex items-center justify-center text-5xl font-bold text-white tracking-widest" style="background-color: rgba(0,0,0,0.2); text-shadow: 2px 2px 4px rgba(0,0,0,0.5);">성공!</div>
        </div>

        <div class="h-10 text-center mb-3 flex items-center justify-center">
             <p id="feedback-text" class="text-lg font-bold">수련을 시작하자!</p>
        </div>
        
        <div class="mb-4">
            <span class="text-lg">🔥 파워</span>
            <div class="w-full bg-gray-200 rounded-full h-6 shadow-inner mt-1">
                <div id="power-progress" class="bg-gradient-to-r from-orange-500 to-red-600 h-6 rounded-full flex items-center justify-center text-white text-sm transition-all duration-300" style="width: 0%;">
                    <span id="power-value">0</span>
                </div>
            </div>
        </div>
        
        <div class="grid grid-cols-1 gap-3">
            <button id="train-btn" class="btn-press bg-gray-700 text-white py-4 rounded-xl shadow-lg hover:bg-gray-900 focus:outline-none focus:ring-4 focus:ring-gray-400">연습하기/운동하기</button>
        </div>
    </div>
    
    <div id="win-popup" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4">
        <div class="bg-white rounded-2xl p-8 text-center shadow-xl jua-font">
            <div class="text-6xl mb-4">👑</div>
            <h2 class="text-3xl font-bold text-red-600 mb-2">당신은 진정한 격파왕!</h2>
            <div class="text-lg text-gray-700 mb-6 space-y-1">
                <p id="final-time">걸린 시간: <span></span></p>
                <p id="final-clicks">클릭 수: <span></span></p>
            </div>
            <button onclick="location.reload()" class="bg-yellow-400 text-gray-800 py-3 px-8 rounded-lg shadow-md hover:bg-yellow-500 focus:outline-none focus:ring-4 focus:ring-yellow-300">다시 도전</button>
        </div>
    </div>

    <script>
        const stages = [
            { name: "나무판", emoji: "🪵", targetPower: 10, threshold: 7 },
            { name: "돌", emoji: "🪨", targetPower: 30, threshold: 24 },
            { name: "큰 바위", emoji: "🗿", targetPower: 60, threshold: 50 },
            { name: "집", emoji: "🏠", targetPower: 100, threshold: 85 },
            { name: "건물", emoji: "🏢", targetPower: 150, threshold: 130 },
            { name: "산", emoji: "⛰️", targetPower: 220, threshold: 200 },
            { name: "산맥", emoji: "🏔️", targetPower: 350, threshold: 300 },
            { name: "지구", emoji: "🌍", targetPower: 600, threshold: 520 },
            { name: "태양", emoji: "☀️", targetPower: 1000, threshold: 850 },
            { name: "우주", emoji: "🌌", targetPower: 1500, threshold: 1300 },
        ];

        const gameState = {
            power: 0,
            currentStageIndex: 0,
            isBreaking: false,
            tutorial: { active: true, step: 1 },
            startTime: null,
            timerInterval: null,
            clickCount: 0,
        };

        const ui = {
            gameContainer: document.getElementById('game-container'),
            feedbackText: document.getElementById('feedback-text'),
            powerValue: document.getElementById('power-value'),
            powerProgress: document.getElementById('power-progress'),
            targetObject: document.getElementById('target-object'),
            winPopup: document.getElementById('win-popup'),
            trainBtn: document.getElementById('train-btn'),
            levelIndicator: document.getElementById('level-indicator'),
            successMessage: document.getElementById('success-message'),
            targetContainer: document.getElementById('target-container'),
            tutorialArrow: document.getElementById('tutorial-arrow'),
            timer: document.getElementById('timer'),
            finalTime: document.querySelector('#final-time span'),
            finalClicks: document.querySelector('#final-clicks span'),
        };

        function updateStageUI() {
            if (gameState.currentStageIndex >= stages.length) {
                stopTimer();
                ui.winPopup.classList.remove('hidden');
                ui.finalTime.textContent = `${((Date.now() - gameState.startTime) / 1000).toFixed(1)}초`;
                ui.finalClicks.textContent = `${gameState.clickCount}회`;
                return;
            }
            const currentStage = stages[gameState.currentStageIndex];
            
            ui.levelIndicator.textContent = `LV. ${gameState.currentStageIndex + 1}`;
            ui.targetObject.textContent = currentStage.emoji;
            ui.targetObject.classList.remove('breaking');
            ui.targetObject.style.opacity = 1;
            ui.targetObject.classList.remove('breakable');
            
            if (gameState.currentStageIndex === 0 && gameState.tutorial.active) {
                updateTutorialUI();
            } else {
                if (gameState.power === 0) showFeedback(`${currentStage.name}을(를) 부수려면 멀었어!`, 'red');
            }
            checkPower();
        }

        function updateTutorialUI() {
            const arrow = ui.tutorialArrow;
            arrow.classList.remove('hidden');

            switch (gameState.tutorial.step) {
                case 1:
                    showFeedback("목표를 클릭해서 격파해보자!", "blue");
                    const targetEl = ui.targetObject;
                    arrow.style.top = `${targetEl.offsetTop - arrow.offsetHeight + 15}px`;
                    arrow.style.left = `${targetEl.offsetLeft + (targetEl.offsetWidth / 2) - (arrow.offsetWidth / 2)}px`;
                    break;
                case 2:
                    showFeedback("파워가 부족하군! 수련을 통해 파워를 모으자!", "red");
                    const btnEl = ui.trainBtn;
                    arrow.style.top = `${btnEl.offsetTop - arrow.offsetHeight + 15}px`;
                    arrow.style.left = `${btnEl.offsetLeft + (btnEl.offsetWidth / 2) - (arrow.offsetWidth / 2)}px`;
                    break;
                case 3:
                    arrow.classList.add('hidden');
                    gameState.tutorial.active = false;
                    break;
            }
        }
        
        function updatePowerUI() {
            const { power, currentStageIndex } = gameState;
            if (currentStageIndex >= stages.length) return;
            const currentStage = stages[currentStageIndex];
            const percentage = Math.min((power / currentStage.targetPower) * 100, 100);
            
            ui.powerValue.textContent = power;
            ui.powerProgress.style.width = `${percentage}%`;
        }
        
        function checkPower() {
            const { power, currentStageIndex } = gameState;
            if (currentStageIndex >= stages.length || (gameState.tutorial.active && gameState.tutorial.step < 3)) return;

            const currentStage = stages[currentStageIndex];
            ui.targetObject.classList.remove('breakable');
            
            if (power >= currentStage.targetPower) {
                ui.targetObject.classList.add('breakable');
                showFeedback(`${currentStage.name}을(를) 부술 수 있어!`, 'green');
            } else if (power >= currentStage.threshold) {
                showFeedback(`${currentStage.name}을(를) 부수려면 얼마 남지 않았어.`, 'blue');
            } else {
                // 파워가 임계값 미만일 때만 '멀었다' 메시지 표시
                if (!ui.feedbackText.textContent.includes('멀었어')) {
                    showFeedback(`${currentStage.name}을(를) 부수려면 멀었어!`, 'red');
                }
            }
        }

        function showFeedback(message, color = 'red') {
            const colorClasses = { red: 'text-red-500', blue: 'text-blue-500', green: 'text-green-500' };
            ui.feedbackText.classList.remove('text-red-500', 'text-blue-500', 'text-green-500');
            ui.feedbackText.classList.add(colorClasses[color]);
            
            // 메시지가 다를 때만 업데이트하고 애니메이션 적용
            if (ui.feedbackText.textContent !== message) {
                ui.feedbackText.textContent = message;
                ui.feedbackText.classList.remove('feedback-update');
                void ui.feedbackText.offsetWidth;
                ui.feedbackText.classList.add('feedback-update');
            }
        }

        function createDestructionEffect() {
            const currentStage = stages[gameState.currentStageIndex];
            const rect = ui.targetObject.getBoundingClientRect();
            const containerRect = ui.targetContainer.getBoundingClientRect();

            for (let i = 0; i < 15; i++) {
                const particle = document.createElement('div');
                particle.classList.add('particle');
                particle.textContent = currentStage.emoji;
                
                const startX = (rect.left + rect.width / 2) - containerRect.left;
                const startY = (rect.top + rect.height / 2) - containerRect.top;
                
                particle.style.left = `${startX}px`;
                particle.style.top = `${startY}px`;

                const x = (Math.random() - 0.5) * 300;
                const y = (Math.random() - 0.5) * 300;
                particle.style.setProperty('--x', `${x}px`);
                particle.style.setProperty('--y', `${y}px`);

                ui.targetContainer.appendChild(particle);
                setTimeout(() => particle.remove(), 800);
            }
        }

        function calculateCritMultiplier(stageIndex) {
            const rand = Math.random();
            const stageBonus = Math.max(0, (stageIndex - 2) * 5);

            let multiplier;
            if (rand < 0.05) {
                 multiplier = 15;
            } else if (rand < 0.20) {
                 multiplier = Math.floor(Math.random() * 4) + 8;
            } else if (rand < 0.50) {
                 multiplier = Math.floor(Math.random() * 3) + 5;
            } else {
                 multiplier = Math.floor(Math.random() * 2) + 3;
            }
            return multiplier + stageBonus;
        }

        function showCritMessage(powerGain) {
            const critMessages = ["Crit!", "굉장해!", "완벽해!", "초월!"];
            const superCritMessages = ["초신성!!", "전설의 일격!", "신의 경지!!"];
            
            let message;
            let colorClass;

            const critElement = document.createElement('div');
            
            if (powerGain >= 20) {
                message = superCritMessages[Math.floor(Math.random() * superCritMessages.length)];
                critElement.style.backgroundImage = 'linear-gradient(to right, #facc15, #ef4444, #ec4899)';
                critElement.style.color = 'transparent';
                critElement.style.backgroundClip = 'text';
                critElement.style.webkitBackgroundClip = 'text';
                critElement.style.fontSize = '2rem';
            } else {
                message = critMessages[Math.floor(Math.random() * critMessages.length)];
                if (powerGain >= 10) colorClass = 'text-purple-500';
                else if (powerGain >= 7) colorClass = 'text-red-500';
                else colorClass = 'text-orange-500';
                critElement.classList.add(colorClass);
            }

            critElement.classList.add('crit-message');
            critElement.innerHTML = `${message}<br/>+${powerGain} 🔥`;
            critElement.style.textShadow = '1px 1px 3px rgba(0,0,0,0.4)';
            
            ui.gameContainer.appendChild(critElement);
            setTimeout(() => critElement.remove(), 1000);
            
            ui.gameContainer.classList.add('crit-shake');
            setTimeout(() => {
                ui.gameContainer.classList.remove('crit-shake');
            }, 400);
        }
        
        ui.trainBtn.addEventListener('click', () => {
            if (gameState.isBreaking || gameState.currentStageIndex >= stages.length) return;
            
            gameState.clickCount++;

            if (gameState.tutorial.active && gameState.tutorial.step === 2) {
                showFeedback("좋아! 조금만 더!", "green");
                gameState.tutorial.step = 3;
                setTimeout(updateTutorialUI, 500);
            }

            let powerGain = 1;
            if (gameState.currentStageIndex >= 2) {
                const critChance = 0.25 + (gameState.currentStageIndex - 2) * 0.08;
                if (Math.random() < critChance) {
                    powerGain = calculateCritMultiplier(gameState.currentStageIndex);
                    showCritMessage(powerGain);
                }
            }

            gameState.power += powerGain;
            updatePowerUI();
            checkPower();
        });

        ui.targetObject.addEventListener('click', () => {
            if (gameState.isBreaking || gameState.currentStageIndex >= stages.length) return;

            if (gameState.tutorial.active && gameState.tutorial.step === 1) {
                showFeedback("나무판을 부수려면 멀었어!", "red");
                gameState.tutorial.step = 2;
                updateTutorialUI();
                return;
            }
            
            const { power, currentStageIndex } = gameState;
            const currentStage = stages[currentStageIndex];

            if (power >= currentStage.targetPower) {
                gameState.isBreaking = true;
                ui.targetObject.classList.add('breaking');
                createDestructionEffect();

                setTimeout(() => {
                    ui.successMessage.classList.add('show');
                    
                    setTimeout(() => {
                        ui.successMessage.classList.remove('show');
                        
                        if (gameState.currentStageIndex === 0) {
                            startTimer();
                        }

                        gameState.currentStageIndex++;
                        gameState.power = 0;
                        updatePowerUI();
                        updateStageUI();
                        gameState.isBreaking = false;
                    }, 1200);
                }, 200);
            } else {
                 if (power >= currentStage.threshold) {
                    showFeedback(`${currentStage.name}을(를) 부수려면 얼마 남지 않았어.`, 'blue');
                } else {
                    showFeedback(`${currentStage.name}을(를) 부수려면 멀었어!`, 'red');
                }
            }
        });

        function startTimer() {
            gameState.startTime = Date.now();
            gameState.timerInterval = setInterval(updateTimer, 100);
        }
        function updateTimer() {
            if (!gameState.startTime) return;
            const elapsedTime = (Date.now() - gameState.startTime) / 1000;
            ui.timer.textContent = `${elapsedTime.toFixed(1)}초`;
        }
        function stopTimer() {
            clearInterval(gameState.timerInterval);
        }

        // 초기화
        updateStageUI();
        updatePowerUI();
    </script>
</body>
</html>



